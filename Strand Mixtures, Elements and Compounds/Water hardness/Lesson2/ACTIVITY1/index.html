<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Shake the Soap!</title>
<style>
    /* Font Imports and Keyframes */
    @font-face {
        font-family: 'Fredoka';
        src: url('../assets/Fredoka-VariableFont_wdth\,wght.ttf') format('truetype'); /* Using a web-hosted version */
    }
    @keyframes glow-pulse {
        0%, 100% { box-shadow: 0 0 10px rgba(251, 176, 59, 0.5), 0 0 20px rgba(251, 176, 59, 0.3); transform: scale(1); }
        50% { box-shadow: 0 0 20px rgba(251, 176, 59, 0.8), 0 0 30px rgba(251, 176, 59, 0.5); transform: scale(1.05); }
    }
    @keyframes glow-pulse-white {
        0%, 100% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.7), 0 0 20px rgba(255, 255, 255, 0.5); transform: scale(1); }
        50% { box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 30px rgba(255, 255, 255, 0.7); transform: scale(1.1); }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideIn { from { transform: translateY(30px) scale(0.95); opacity: 0; } to { transform: translateY(0) scale(1); } }
    @keyframes bubble {
        0% { transform: translateY(0) scale(1); opacity: 1; }
        100% { transform: translateY(-100px) scale(1.5); opacity: 0; }
    }

    ::-webkit-scrollbar{ display: none; }

    /* Root Variables */
    :root {
        --primary-color: #5D04B2;
        --secondary-color: #fbb03b;
        --correct-color: #4caf50;
        --incorrect-color: #e74c3c;
        --intermediate-color: #ff9800;
        --text-color-dark: #333;
        --text-color-light: #fff;
        --card-background-light: #ffffff;
        --shadow-dark: rgba(0, 0, 0, 0.3);
        --border-radius: 1rem;
        --header-font: 'Fredoka', sans-serif;
    }

    /* Global Reset & Base Styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #f0f4f8;
        font-family: var(--header-font), sans-serif;
        padding: 0rem;
    }

    #game-wrapper {
        width: 100%;
        max-width: 1200px;
        height: auto;
        max-height: 100%;
        aspect-ratio: 16 / 9;
        box-shadow: 0 0.9375rem 2.5rem var(--shadow-dark);
        overflow: hidden;
        position: relative;
        display: flex;
        flex-direction: column;
        background: #fff;
    }

    #game-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .screen {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        display: flex;
        flex-direction: column;
        transition: opacity 0.5s ease-in-out;
        overflow: hidden;
    }
    .screen.hidden { opacity: 0; pointer-events: none; }
    
    #start-screen {
        background-image: url(images/gamebg.jpg);
       background-size: cover;
       background-position: center;
       justify-content: center;
       align-items: center;
       padding: 2rem;
       text-align: center;
    }
    #start-screen h1 {
       font-size: clamp(2.5rem, 5vw, 4.2rem);
       color: var(--text-color-light);
       margin-bottom: 1.2rem;
       text-shadow: 0 4px 8px rgba(0,0,0,0.3);
       font-weight: 500;
    }
    .start-button { 
        background: #FBB03B; color: #fff; font-weight: 900;
        font-size: 1.1rem; border: 3px solid #fff; border-radius: 3rem;
        padding: 0.75rem 2.25rem; margin-top: 1rem; cursor: pointer;
        text-shadow: 0 2px 0 #b88b2a; transition: all 0.2s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .start-button:hover { transform: scale(1.06); box-shadow: 0 6px 24px rgba(0,0,0,0.18); }

    #game-screen { background: #f8f9ff; }

    .game-top-section {
        width: 100%; flex-shrink: 0; display: flex; justify-content: space-between;
        align-items: center; background-color: var(--primary-color);
        color: var(--text-color-light); padding: clamp(0.5rem, 1.5vmin, 0.75rem) clamp(0.75rem, 2vmin, 1.25rem);
        box-shadow: 0 2px 10px rgba(0,0,0,0.2); gap: 1rem; flex-wrap: wrap;
    }
    
    #game-title {
        font-size: clamp(1.2rem, 4vmin, 1.8rem); font-weight: 600;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3); flex: 1 1 300px; min-width: 0;
    }

    .progress-area { display: flex; align-items: center; gap: clamp(0.5rem, 1.5vw, 1rem); flex-shrink: 0; }
    #progress-container {
        width: clamp(100px, 20vw, 200px); background-color: rgba(255,255,255,0.3);
        border-radius: 1rem; height: clamp(15px, 2.5vmin, 20px);
        border: 2px solid #fff; position: relative; overflow: hidden;
    }
    #progress-bar {
        height: 100%; width: 0%; background: #FFFF00;
        border-radius: 0.8rem; transition: width 0.5s ease;
    }
    #progress-text {
        color: var(--text-color-light); font-weight: 700;
        font-size: clamp(0.75rem, 2vmin, 1rem); text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
    }
    .instructions-icon {
        width: 40px; height: 40px; background: rgba(255, 255, 255, 0.2); border-radius: 50%;
        display: flex; align-items: center; justify-content: center; cursor: pointer;
        transition: all 0.3s ease; flex-shrink: 0; animation: glow-pulse-white 2s infinite;
    }
    .instructions-icon:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.1); }
    .instructions-icon svg { fill: white; width: 20px; height: 20px; }

    .game-content {
        flex: 1; display: flex; padding: clamp(0.5rem, 1vw, 1rem);
        overflow: hidden; position: relative; flex-direction: column;
    }
    
    #experiment-title {
        text-align: center; font-size: clamp(1.1rem, 3vmin, 1.5rem); color: var(--primary-color);
        font-weight: 600; margin-bottom: clamp(0.25rem, 1vh, 0.5rem); flex-shrink: 0;
        min-height: 1.2em; /* Prevents layout shift */
    }

    #canvas-container {
        flex: 1; position: relative;
        min-width: 0; display: flex; align-items: center; justify-content: center;
    }

    canvas {
        display: block; background-color: transparent;
        border-radius: var(--border-radius);
        cursor: pointer;
    }
    
    #controls-and-predictions {
        display: flex; justify-content: space-around; align-items: center;
        padding: clamp(0.5rem, 1.5vh, 1rem); border-top: 1px solid #dee2e6;
        background-color: #e9ecef; flex-wrap: wrap; gap: 1rem;
    }
    
    .prediction-section { text-align: center; }
    .prediction-section h3 {
        font-size: clamp(1rem, 2.5vmin, 1.2rem); margin-bottom: 0.5rem;
        color: var(--text-color-dark);
    }
    .prediction-buttons { display: flex; gap: 1rem; }
    .prediction-btn {
        font-family: var(--header-font); font-size: clamp(0.8rem, 2vw, 1rem);
        padding: 0.5rem 1rem; border: 2px solid #ccc; border-radius: 2rem;
        cursor: pointer; background-color: #fff; color: #555;
        transition: all 0.2s ease;
    }
    .prediction-btn:hover { border-color: var(--secondary-color); background-color: #fff9f0; }
    .prediction-btn.selected {
        border-color: var(--primary-color); background-color: var(--primary-color);
        color: #fff; box-shadow: 0 2px 8px rgba(93, 4, 178, 0.4);
        transform: scale(1.05);
    }
    
    #shake-btn {
        font-family: var(--header-font); font-size: clamp(1rem, 2.5vw, 1.2rem); font-weight: bold;
        color: white; border: none; border-radius: 50px; padding: clamp(0.6rem, 2.5vh, 0.8rem) clamp(1.2rem, 5vw, 2.2rem);
        cursor: pointer; transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2), inset 0 -4px 0 rgba(0,0,0,0.2);
        text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        background: linear-gradient(145deg, #2ecc71, #27ae60);
    }
    #shake-btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0,0,0,0.3), inset 0 -2px 0 rgba(0,0,0,0.1); }
    #shake-btn:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 2px 8px rgba(0,0,0,0.2), inset 0 -1px 0 rgba(0,0,0,0.2); }
    #shake-btn:disabled { background: #bdc3c7 !important; color: #7f8c8d !important; cursor: not-allowed; box-shadow: 0 2px 5px rgba(0,0,0,0.1), inset 0 -2px 0 rgba(0,0,0,0.1); }

    /* Hint Icon */
    .hint-icon {
        position: absolute; bottom: 1rem; right: 1rem; width: 50px; height: 50px;
        background: var(--secondary-color); border-radius: 50%; border: 2px solid white;
        display: flex; align-items: center; justify-content: center; cursor: pointer;
        transition: all 0.3s ease; z-index: 1001; box-shadow: 0 4px 15px rgba(251, 176, 59, 0.4);
        animation: glow-pulse 2s infinite;
    }
    .hint-icon:hover { transform: scale(1.1); box-shadow: 0 6px 25px rgba(251, 176, 59, 0.8); }
    .hint-icon svg { fill: white; width: 24px; height: 24px; }

    /* Modal Styles */
    .modal-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
        z-index: 3000; display: flex; justify-content: center; align-items: center;
        animation: fadeIn 0.3s ease;
    }
    .modal-overlay.hidden { display: none; }
    .modal-content {
        background: var(--card-background-light); padding: 2.5rem;
        border-radius: var(--border-radius); text-align: center;
        width: 90%; max-width: 600px;
        animation: slideIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
    }
    .modal-content h2 {
      font-size: clamp(1.5rem, 4vw, 2rem); font-weight: 600; margin-bottom: 1.5rem;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
    }
    #feedback-title svg {
        width: clamp(2rem, 5vw, 2.5rem);
        height: clamp(2rem, 5vw, 2.5rem);
        flex-shrink: 0;
    }
    .modal-content p { font-size: clamp(1rem, 2.5vw, 1.2rem); line-height: 1.6; color: var(--text-color-dark); }
     .modal-content ul {
        list-style-type: none; text-align: left; margin-top: 1rem; padding: 0;
    }
    .modal-content li { margin-bottom: 0.8rem; padding-left: 1.5rem; position: relative; }
    .modal-content li::before { content: ''; position: absolute; left: 0; }
    .modal-content li ul li::before { content: ''; }


    .modal-btn {
        width: 100%; padding: 1rem; font-size: 1.2rem; font-weight: 700;
        border: none; border-radius: 0.75rem; cursor: pointer; color: #fff;
        background-color: var(--primary-color); transition: transform 0.2s, box-shadow 0.2s;
        margin-top: 1.5rem;
    }
    .modal-btn:hover { transform: scale(1.02); }

    #activity-intro-overlay .modal-content, #instructions-overlay .modal-content { border-top: 8px solid var(--primary-color); }
    #instructions-overlay .modal-content { max-height: 80vh; overflow-y: auto; }
    
    #activity-intro-overlay .modal-content p {
        text-align: left; background: #f8f9fa; padding: 1.5rem;
        border-radius: 0.75rem; border-left: 4px solid var(--primary-color);
        line-height: 1.5; font-size: clamp(1.1rem, 2.5vw, 1.3rem); color: var(--text-color-dark);
    }
    #instructions-overlay .modal-content ul, #hint-overlay .modal-content ul {
        text-align: left; padding: 0; font-size: 1.1rem; line-height: 1.5;
    }
    #instructions-overlay .modal-content li, #hint-overlay .modal-content li {
        margin-bottom: 0.8rem; font-size: 1.1em; line-height: 1.5;
    }
    #hint-overlay .modal-content { border-top: 8px solid var(--secondary-color); }
    #hint-overlay h2 { color: var(--secondary-color); }
    #hint-overlay .modal-btn { background-color: var(--secondary-color); }

    #feedback-modal-overlay .modal-content { border-top: 8px solid; }

    #completion-overlay {
        background-image: url(images/gamebg.jpg);
        background-size: cover;
        background-position: center;
        flex-direction: column;
        gap: 1.5rem;
        justify-content: center;
        padding: 1rem;
    }
    .completion-title {
        color: var(--text-color-light); 
        font-size: clamp(2.5rem, 5vw, 3rem);
        font-family: var(--header-font); 
        text-shadow: 0 0.1875rem 0.375rem rgba(0,0,0,0.5);
        text-align: center;
        font-weight: 600;
    }
  
     .completion-modal-content {
        background: transparent;
        box-shadow: none;
        width: 100%;
        max-width: 100%;
        padding: 0;
        overflow: visible;
        margin: 0 auto;
        border: none;
    }
    .completion-image {
        display: block;
        width: 60%;
        height: auto;
        object-fit: contain;
        animation: fadeIn 0.5s ease-out;
        border: 4px solid var(--secondary-color);
        border-radius: 1rem;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        justify-self: center;
        align-self: center;
    }
    .completion-buttons {
        display: flex;
        justify-content: space-between;
        gap: 1.5rem;
        width: 100%;
    }
    
    .completion-btn {
        font-family: var(--header-font); background: var(--secondary-color); color: #fff;
        font-weight: 500; 
        font-size: 1.2rem;
        border: 0.1875rem solid #fff; border-radius: 3rem; 
        padding: clamp(0.5rem, 1.5vmin, 0.75rem) clamp(1.25rem, 3vmin, 2rem);
        cursor: pointer; transition: all 0.2s;
        box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.2);
        text-shadow: 0 0.125rem 0 #b88b2a; text-decoration: none;
        min-width: 8.75rem; /* 140px */
    }
    .completion-btn:hover { 
        transform: scale(1.05); 
        box-shadow: 0 0.5rem 1.25rem rgba(0,0,0,0.2);
    }
    
    .visually-hidden {
        position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0;
        overflow: hidden; clip: rect(0, 0, 0, 0); border: 0;
    }
    @media(max-width:1024px){
        #game-wrapper {
            width: 100vw !important; height: 100% !important;
            min-width: 100vw !important; min-height: 100% !important;
            border-radius: 0 !important; max-width: none !important;
            aspect-ratio: unset !important; box-shadow: none;
        }
    }

    @media (max-width: 991px) {
      /* This class is not used directly, but the font size is set in JS for canvas. */
      .bottle-label-text {
        font-size: 2rem !important;
      }
      #activity-intro-overlay .modal-content {
        height: 98vh;
        overflow-y: auto;
      }
      .completion-btn{
        font-size: 1rem;
        padding: clamp(0.4rem, 1.2vmin, 0.6rem) clamp(1rem, 2.5vmin, 1.5rem);
        min-width: 7rem; /* 112px */
      }
    }
    @media(min-width:768px) and (max-width: 991px) {
        .completion-image{
            width: 50%;
        }  
    }
</style>
</head>
<body>
<div id="game-wrapper">
   <div id="game-container">
        <!-- Start Screen -->
        <div id="start-screen" class="screen">
            <h1>Shake the Soap!</h1>
            <button class="start-button">Start Activity</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen hidden">
            <div class="game-top-section">
               <h1 id="game-title">Shake the Soap!</h1>
               <div class="progress-area">
                   <div id="progress-container"><div id="progress-bar"></div></div>
                   <div id="progress-text">0 / 6</div>
               </div>
               <div class="instructions-icon" id="instructions-icon">
                   <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
               </div>
            </div>
            <div class="game-content">
                <h2 id="experiment-title">Click on a sample bottle to add soap.</h2>
                <main id="canvas-container">
                    <canvas id="activityCanvas" role="img" aria-label="Soap and water experiment simulation area"></canvas>
                </main>
                 <div class="hint-icon" id="hint-icon">
                    <svg viewBox="0 0 24 24"><path d="M9 21c0 .5.4 1 1 1h4c.6 0 1-.5 1-1v-1H9v1zm3-19C8.1 2 5 5.1 5 9c0 2.4 1.2 4.5 3 5.7V17c0 .5.4 1 1 1h6c.6 0 1-.5 1-1v-2.3c1.8-1.3 3-3.4 3-5.7 0-3.9-3.1-7-7-7z"></path></svg>
                </div>
            </div>
            <div id="controls-and-predictions">
                <div class="prediction-section">
                    <h3>What's your observation?</h3>
                    <div class="prediction-buttons">
                         <button class="prediction-btn" data-prediction="soft">Soft</button>
                         <button class="prediction-btn" data-prediction="intermediate">Intermediate</button>
                         <button class="prediction-btn" data-prediction="hard">Hard</button>
                    </div>
                </div>
                <button id="shake-btn" disabled>Shake</button>
            </div>
        </div>

        <!-- Modals and Overlays -->
        <div id="activity-intro-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>Activity Introduction</h2>
                <p>Water can be tricky when it comes to soap. Some make big bubbles  others leave ugly scum. Get ready to investigate! In this virtual lab, you will shake six water samples and watch what happens when soap is added. Lather means soft water. Scum means hard water. Let us test and see!</p>
                <button class="modal-btn" id="intro-continue-btn">Continue</button>
            </div>
        </div>

        <div id="instructions-overlay" class="modal-overlay hidden">
           <div class="modal-content">
               <h2>Learner Instructions</h2>
               <ul>
                   <li>Click on a sample bottle to add soap.</li>
                   <li>Press the <strong>Shake</strong> button to mix.</li>
                   <li>Watch carefully  is there foam or scum?</li>
                   <li>Decide whether the water is <strong>Soft</strong>, <strong>Hard</strong>, or <strong>Intermediate</strong>.</li>
                   <li>Complete all 6 experiments to finish the activity!</li>
               </ul>
               <button class="modal-btn" id="close-instructions-btn">Got it!</button>
           </div>
        </div>

        <div id="hint-overlay" class="modal-overlay hidden">
           <div class="modal-content">
               <h2>Here is a Hint</h2>
               <p>Soft water makes soap foam quickly. Hard water leaves a scum ring. Some water gives little foam  this means intermediate hardness.</p>
               <button class="modal-btn" id="close-hint-btn">Got it</button>
           </div>
        </div>
       
        <div id="feedback-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <h2 id="feedback-title"></h2><p id="feedback-text"></p>
                <button class="modal-btn" id="feedback-continue-btn">Next</button>
            </div>
        </div>

        <div id="completion-overlay" class="modal-overlay hidden">
            <h2 class="completion-title">Activity Wrap Up!</h2>
            <div class="modal-content completion-modal-content">
                <img src="images/complete.jpg" alt="Activity Complete" class="completion-image">
            </div>
            <div class="completion-buttons">
                <button class="completion-btn" id="btn-restart">Restart Activity</button>
                <button class="completion-btn" id="btn-next">Next Activity</button>

            </div>
       </div>
        
        <div id="aria-live-announcer" class="visually-hidden" aria-live="polite"></div>
        
    <!-- Audio Files -->
    <audio id="sound-correct" src="audio/ding.mp3" preload="auto"></audio>
    <audio id="sound-incorrect" src="audio/buzz.mp3" preload="auto"></audio>
    <audio id="sound-intro" src="audio/intro.mp3" preload="auto"></audio>
    <audio id="sound-outro" src="audio/outro.mp3" preload="auto"></audio>
    <audio id="sound-fizz" src="audio/fizz.mp3" preload="auto"></audio>

   </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Activity Data ---
    const SAMPLES = [
        { name: 'Distilled', result: 'lather', classification: 'soft', feedback: { correct: "Correct. Distilled water is pure and soft  it allows rich lather to form.", incorrect: "Check again  this water is highly purified, it should foam easily." } },
        { name: 'Rain', result: 'lather', classification: 'soft', feedback: { correct: "Well done! Rainwater is naturally soft and helps soap lather well.", incorrect: "Try again. This water is soft  it lathers quickly without any scum." } },
        { name: 'Tap', result: 'weak-foam', classification: 'intermediate', feedback: { correct: "That's right. Tap water often contains some minerals, giving partial lather.", incorrect: "Look closely. Tap water usually lathers a bit, but not as much as pure water." } },
        { name: 'Borehole', result: 'scum', classification: 'hard', feedback: { correct: "Correct. Borehole water usually contains calcium and magnesium  this causes scum.", incorrect: "Check again  scum formation means the water is hard." } },
        { name: 'River', result: 'scum', classification: 'hard', feedback: { correct: "Yes. River water often has dissolved minerals that react with soap.", incorrect: "Look at the result  no lather means it is hard water." } },
        { name: 'Sea', result: 'scum', classification: 'hard', feedback: { correct: "Correct. Sea water has high salt content. Soap will not lather in it.", incorrect: "Re-evaluate. Salty sea water is hard  it does not let soap work properly." } }
    ];
    
    const ICONS = {
        correct: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`,
        incorrect: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`,
    };

    // --- DOM Elements ---
    const startScreen = document.getElementById('start-screen'), gameScreen = document.getElementById('game-screen');
    const startBtn = document.querySelector('.start-button');
    const canvas = document.getElementById('activityCanvas'), ctx = canvas.getContext('2d');
    const canvasContainer = document.getElementById('canvas-container');
    const experimentTitle = document.getElementById('experiment-title');
    const shakeBtn = document.getElementById('shake-btn');
    const predictionBtns = document.querySelectorAll('.prediction-btn');
    const progressBar = document.getElementById('progress-bar'), progressText = document.getElementById('progress-text');
    const activityIntroOverlay = document.getElementById('activity-intro-overlay'), introContinueBtn = document.getElementById('intro-continue-btn');
    const instructionsIcon = document.getElementById('instructions-icon'), instructionsOverlay = document.getElementById('instructions-overlay'), closeInstructionsBtn = document.getElementById('close-instructions-btn');
    const hintIcon = document.getElementById('hint-icon'), hintOverlay = document.getElementById('hint-overlay'), closeHintBtn = document.getElementById('close-hint-btn');
    const feedbackModalOverlay = document.getElementById('feedback-modal-overlay'), feedbackTitle = document.getElementById('feedback-title'), feedbackText = document.getElementById('feedback-text'), feedbackContinueBtn = document.getElementById('feedback-continue-btn');
    const completionOverlay = document.getElementById('completion-overlay');
    // --- Audio ---
    const sounds = {
        correct: document.getElementById('sound-correct'),
        incorrect: document.getElementById('sound-incorrect'),
        intro: document.getElementById('sound-intro'),
        outro: document.getElementById('sound-outro'),
        fizz: document.getElementById('sound-fizz'),
        thud: document.getElementById('sound-fizz'),
        drip: document.getElementById('sound-fizz')
    };
    
    // --- Get CSS Variables for Canvas ---
    const PRIMARY_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
    const HEADER_FONT = getComputedStyle(document.body).fontFamily;

    // --- Canvas & Sizing ---
    let W, H, dpr = window.devicePixelRatio || 1;
    let bottles = [];

    // --- Game State ---
    let gameState = 'intro'; // intro, select, classify, shaking, result, feedback, complete
    let currentSampleIndex = -1;
    let userClassification = null;
    let animationState = { type: null, startTime: 0, duration: 0, shakeOffset: {x: 0, y: 0, rotation: 0} };
    let particles = [];
    let completedSamples = [];

    // --- Sound Management ---
    function playSound(sound) { if(sound) { sound.currentTime = 0; sound.play().catch(e => console.error("Audio play failed:", e)); } }
    function stopSound(sound) { if(sound) { sound.pause(); sound.currentTime = 0; } }
    
    // --- Responsive Canvas Sizing ---
    function resize() {
        const containerRect = canvasContainer.getBoundingClientRect();
        if (containerRect.width <= 0 || containerRect.height <= 0) return;

        W = containerRect.width;
        H = containerRect.height;

        canvas.style.width = `${W}px`;
        canvas.style.height = `${H}px`;
        canvas.width = Math.round(W * dpr);
        canvas.height = Math.round(H * dpr);

        setupBottles();
        draw();
    }

    // --- Game Setup ---
    function setupBottles() {
        const oldBottles = [...bottles];
        bottles = [];
        const bottleCount = SAMPLES.length;
        // Increase bottle size for small screens
        let bottleHeight = H * 0.45;
        let bottleWidth = Math.min(W / (bottleCount + 1), bottleHeight / 2.2);
        if (window.innerWidth <= 991) {
            bottleHeight = H * 0.5;
            bottleWidth = Math.min(W / (bottleCount + 1), bottleHeight / 1.5);
        }
        const spacing = (W - bottleCount * bottleWidth) / (bottleCount + 1);
        const yPos = H / 2 - bottleHeight / 2;

        SAMPLES.forEach((sample, i) => {
            const isCompleted = completedSamples.includes(i);
            const isCurrentlySelected = i === currentSampleIndex;
            let existingBottle = oldBottles.find(b => b.name === sample.name);
            let x = existingBottle ? existingBottle.x : spacing * (i + 1) + bottleWidth * i;
            let y = existingBottle ? existingBottle.y : yPos;
            let scale = existingBottle ? existingBottle.scale : 1;

            bottles.push({
                ...sample,
                x: x,
                y: y,
                width: bottleWidth,
                height: bottleHeight,
                targetX: isCurrentlySelected ? W / 2 - (bottleWidth * 1.5) / 2 : spacing * (i + 1) + bottleWidth * i,
                targetY: isCurrentlySelected ? H / 2 - (bottleHeight * 1.5) / 2 : yPos,
                scale: scale,
                targetScale: isCurrentlySelected ? 1.5 : (gameState === 'select' ? 1 : 0),
                isCompleted: isCompleted,
            });
        });
    }

    function startGame() {
        gameState = 'select';
        currentSampleIndex = -1;
        userClassification = null;
        completedSamples = [];
        updateProgress();
        resize();
        experimentTitle.textContent = "Click on a sample bottle to add soap.";
    }

    // --- UI, Feedback & State ---
    function updateProgress() {
        const total = SAMPLES.length;
        const count = completedSamples.length;
        progressBar.style.width = `${(count / total) * 100}%`;
        progressText.textContent = `${count} / ${total}`;
    }

    function showFeedbackModal(isCorrectGuess) {
        gameState = 'feedback';
        const sample = SAMPLES[currentSampleIndex];
        const feedback = sample.feedback;
        
        const titleText = isCorrectGuess ? "Correct!" : "Not Quite!";
        const message = isCorrectGuess ? feedback.correct : feedback.incorrect;
        const icon = isCorrectGuess ? ICONS.correct : ICONS.incorrect;
        
        const modalContent = feedbackModalOverlay.querySelector('.modal-content');
        const modalBtn = feedbackModalOverlay.querySelector('.modal-btn');
        feedbackTitle.innerHTML = `${icon}<span>${titleText}</span>`;
        feedbackText.textContent = message;

        const color = isCorrectGuess ? 'var(--correct-color)' : 'var(--incorrect-color)';
        modalContent.style.borderColor = color;
        feedbackTitle.style.color = color;
        modalBtn.style.backgroundColor = color;
        
        if (isCorrectGuess) {
             if (!completedSamples.includes(currentSampleIndex)) {
                completedSamples.push(currentSampleIndex);
                bottles[currentSampleIndex].isCompleted = true;
            }
            updateProgress();
            feedbackContinueBtn.textContent = completedSamples.length === SAMPLES.length ? "Continue" : "Next";
            feedbackContinueBtn.dataset.action = "next";
        } else {
            feedbackContinueBtn.textContent = "Try Again";
            feedbackContinueBtn.dataset.action = "retry";
        }
        
        feedbackModalOverlay.classList.remove('hidden');
        playSound(isCorrectGuess ? sounds.correct : sounds.incorrect);
    }
    
    function showCompletionScreen(){
        gameState = 'complete';
        completionOverlay.classList.remove('hidden');
        playSound(sounds.outro);
    }
    
    // --- Drawing Functions ---
    function draw() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(dpr, dpr);

        bottles.forEach((bottle, i) => {
            bottle.x += (bottle.targetX - bottle.x) * 0.1;
            bottle.y += (bottle.targetY - bottle.y) * 0.1;
            bottle.scale += (bottle.targetScale - bottle.scale) * 0.1;
            
            ctx.save();
            const bottleCenterX = bottle.x + (bottle.width * bottle.scale) / 2;
            const bottleCenterY = bottle.y + (bottle.height * bottle.scale) / 2;

            if (i === currentSampleIndex && animationState.type === 'shaking') {
                ctx.translate(bottleCenterX + animationState.shakeOffset.x, bottleCenterY + animationState.shakeOffset.y);
                ctx.rotate(animationState.shakeOffset.rotation);
            } else {
                ctx.translate(bottleCenterX, bottleCenterY);
            }
            
            ctx.scale(bottle.scale, bottle.scale);
            drawBottle(bottle, -bottle.width / 2, -bottle.height / 2);
            ctx.restore();
        });
        
         if (animationState.type) {
            drawParticles();
        }

        ctx.restore();
    }

    function drawBottle(bottle, offsetX = 0, offsetY = 0) {
        const { width, height } = bottle;
        const cornerRadius = width * 0.2;
        ctx.save();
        
        if (bottle.isCompleted) {
            ctx.globalAlpha = 0.5;
        } else if (currentSampleIndex !== -1 && bottles[currentSampleIndex] !== bottle) {
             ctx.globalAlpha = 0.3;
        }

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2.5;

        // Main body
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY + height * 0.25);
        ctx.lineTo(offsetX, offsetY + height - cornerRadius);
        ctx.quadraticCurveTo(offsetX, offsetY + height, offsetX + cornerRadius, offsetY + height);
        ctx.lineTo(offsetX + width - cornerRadius, offsetY + height);
        ctx.quadraticCurveTo(offsetX + width, offsetY + height, offsetX + width, offsetY + height - cornerRadius);
        ctx.lineTo(offsetX + width, offsetY + height * 0.25);
        
        // Shoulders
        ctx.quadraticCurveTo(offsetX + width, offsetY + height * 0.15, offsetX + width * 0.75, offsetY + height * 0.15);
        ctx.lineTo(offsetX + width * 0.25, offsetY + height * 0.15);
        ctx.quadraticCurveTo(offsetX, offsetY + height * 0.15, offsetX, offsetY + height * 0.25);
        ctx.closePath();
        
        ctx.fillStyle = 'rgba(200, 220, 255, 0.6)';
        ctx.fill();
        ctx.stroke();

        // Water
        ctx.fillStyle = 'rgba(135, 206, 250, 0.7)';
        ctx.fillRect(offsetX + width * 0.05, offsetY + height * 0.5, width * 0.9, height * 0.45);

        // Neck and cap
        ctx.fillStyle = '#666';
        ctx.fillRect(offsetX + width * 0.25, offsetY, width * 0.5, height * 0.15);
        ctx.strokeRect(offsetX + width * 0.25, offsetY, width * 0.5, height * 0.15);


        // Label
        ctx.fillStyle = '#fff';
        ctx.fillRect(offsetX + width * 0.1, offsetY + height * 0.6, width * 0.8, height * 0.2);
        ctx.strokeRect(offsetX + width * 0.1, offsetY + height * 0.6, width * 0.8, height * 0.2);
        ctx.fillStyle = '#000';
        // Responsive font size for sample names on small screens
        let labelFontSize = width * 0.18;
        if (window.innerWidth <= 991) {
            labelFontSize = width * 0.2;
        }
        ctx.font = `bold ${labelFontSize}px ${HEADER_FONT}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(bottle.name, offsetX + width / 2, offsetY + height * 0.7);
        
        if(bottle.isCompleted) {
            ctx.fillStyle = 'green';
            ctx.font = `bold ${width * 0.4}px ${HEADER_FONT}`;
            ctx.fillText('✔', offsetX + width / 2, offsetY + height * 0.35);
        }

        ctx.restore();
    }

    function createParticles(isFinalBurst = false) {
        if (isFinalBurst) particles = [];
        
        const bottle = bottles[currentSampleIndex];
        const resultType = bottle.result;
        const bottleCenterX = bottle.x + (bottle.width * bottle.scale) / 2;
        const waterTopY = bottle.y + (bottle.height * bottle.scale * 0.5);
        const waterHeight = bottle.height * bottle.scale * 0.45;

        let count = 0;
        if(isFinalBurst) {
            if(resultType === 'lather') count = 100;
            if(resultType === 'weak-foam') count = 25;
            if(resultType === 'scum') count = 50;
        } else { // Continuous creation
            if(resultType === 'lather') count = 5;
            if(resultType === 'weak-foam') count = 2;
        }


        for (let i = 0; i < count; i++) {
            const x = bottleCenterX + (Math.random() - 0.5) * (bottle.width * bottle.scale * 0.8);
            const y = waterTopY + Math.random() * waterHeight;

            if (resultType === 'scum') {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2,
                    radius: Math.random() * 2 + 1,
                    alpha: 0.8,
                    color: 'rgba(139, 69, 19, 0.7)'
                });
            } else { 
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 0.5, vy: -Math.random() * 1 - 0.5,
                    radius: Math.random() * 4 + 2,
                    alpha: 1,
                    color: 'rgba(255, 255, 255, 0.8)'
                });
            }
        }
    }

    function drawParticles() {
        const bottle = bottles[currentSampleIndex];
        if(!bottle) return;
        
        const bottleLeft = bottle.x;
        const bottleRight = bottle.x + bottle.width * bottle.scale;
        const waterTopY = bottle.y + (bottle.height * bottle.scale * 0.5);
        
        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= 0.003;

            if (p.alpha <= 0) {
                particles.splice(i, 1);
            } else {
                if (bottle.result !== 'scum' && p.y < waterTopY) {
                    p.vy = 0;
                    p.vx = 0;
                }
                 if (p.x < bottleLeft || p.x > bottleRight) {
                    p.vx *= -1;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color.replace(/, [0-9.]+\)/, `, ${p.alpha})`);
                ctx.fill();
            }
        });
    }

    // --- Animation & Game Loop ---
    function gameLoop(timestamp) {
        if (animationState.type === 'shaking') {
            const elapsed = timestamp - animationState.startTime;
            const progress = Math.min(elapsed / animationState.duration, 1);
            
            if (progress < 1) {
                animationState.shakeOffset.rotation = Math.sin(progress * Math.PI * 8) * 0.15;
                animationState.shakeOffset.x = Math.sin(progress * Math.PI * 10) * 8;
                if (Math.random() > 0.5) createParticles();
            } else {
                animationState.type = 'result';
                animationState.startTime = timestamp;
                animationState.duration = 5500;
                animationState.shakeOffset = {x:0, y:0, rotation: 0};
                createParticles(true);
                const result = bottles[currentSampleIndex].result;
                if(result === 'lather') playSound(sounds.fizz);
                else if(result === 'scum') playSound(sounds.thud);
                else if(result === 'weak-foam') playSound(sounds.drip);
            }
        } else if (animationState.type === 'result') {
            const elapsed = timestamp - animationState.startTime;
            if (elapsed > animationState.duration) {
                animationState.type = null;
                const isCorrect = userClassification === bottles[currentSampleIndex].classification;
                showFeedbackModal(isCorrect);
            }
        }
        
        draw();
        requestAnimationFrame(gameLoop);
    }
    
    // --- Event Handlers ---
    function handleCanvasClick(e) {
        if (gameState !== 'select') return;

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * W;
        const y = (e.clientY - rect.top) / rect.height * H;

        bottles.forEach((bottle, i) => {
            if (!bottle.isCompleted && x > bottle.x && x < bottle.x + bottle.width && y > bottle.y && y < bottle.y + bottle.height) {
                currentSampleIndex = i;
                gameState = 'classify';
                experimentTitle.textContent = `Selected: ${bottle.name}. What is your observation?`;
                predictionBtns.forEach(btn => btn.disabled = false);
                
                bottles.forEach((b, idx) => {
                    if(idx === i) {
                        b.targetScale = 1.5;
                        b.targetX = W / 2 - (b.width * b.targetScale) / 2;
                        b.targetY = H / 2 - (b.height * b.targetScale) / 2;
                    } else {
                        b.targetScale = 0;
                    }
                });
            }
        });
    }

    function handlePrediction(e) {
        if (gameState !== 'classify') return;

        userClassification = e.currentTarget.dataset.prediction;
        predictionBtns.forEach(btn => btn.classList.remove('selected'));
        e.currentTarget.classList.add('selected');
        shakeBtn.disabled = false;
    }

    // --- Initialization ---
    function init() {
        startBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            activityIntroOverlay.classList.remove('hidden');
            playSound(sounds.intro);
            sendEvent(ActivityEvent.START_ACTIVITY, {activityName:"Shake the Soap!"});
        });

        introContinueBtn.addEventListener('click', () => {
            activityIntroOverlay.classList.add('hidden');
            stopSound(sounds.intro);
            startGame();
        });
        
        feedbackContinueBtn.addEventListener('click', () => {
             feedbackModalOverlay.classList.add('hidden');
             const action = feedbackContinueBtn.dataset.action;

             if (action === "next") {
                 if (completedSamples.length === SAMPLES.length) {
                     showCompletionScreen();
                 } else {
                     gameState = 'select';
                     currentSampleIndex = -1;
                     userClassification = null;
                     particles = [];
                     predictionBtns.forEach(btn => {
                         btn.classList.remove('selected');
                         btn.disabled = true;
                     });
                     shakeBtn.disabled = true;
                     experimentTitle.textContent = "Click on a sample bottle to add soap.";
                     
                     bottles.forEach(b => {
                        b.targetScale = 1;
                     });
                     setupBottles();
                 }
             } else if (action === "retry") {
                 gameState = 'classify';
                 userClassification = null;
                 particles = [];
                 predictionBtns.forEach(btn => {
                     btn.classList.remove('selected');
                     btn.disabled = false;
                 });
                 shakeBtn.disabled = true;
                 experimentTitle.textContent = `Selected: ${SAMPLES[currentSampleIndex].name}. Try again.`;
             }
        });

        instructionsIcon.addEventListener('click', () => instructionsOverlay.classList.remove('hidden'));
        closeInstructionsBtn.addEventListener('click', () => instructionsOverlay.classList.add('hidden'));
        
        hintIcon.addEventListener('click', () => hintOverlay.classList.remove('hidden'));
        closeHintBtn.addEventListener('click', () => hintOverlay.classList.add('hidden'));

        predictionBtns.forEach(btn => {
            btn.addEventListener('click', handlePrediction);
            btn.disabled = true;
        });
        
        shakeBtn.addEventListener('click', () => {
            gameState = 'shaking';
            predictionBtns.forEach(btn => btn.disabled = true);
            shakeBtn.disabled = true;

            animationState.type = 'shaking';
            animationState.startTime = performance.now();
            animationState.duration = 2000; 
        });

        document.getElementById('btn-restart').addEventListener('click', () => {
            stopSound(sounds.outro);
            completionOverlay.classList.add('hidden');
            startGame();
        });
        document.getElementById('btn-next').addEventListener('click', () => {
            window.location.href = "../ACTIVITY2/index.html";
            sendEvent(ActivityEvent.END_ACTIVITY, {activityName:"Shake the Soap!"});
        });
        
        canvas.addEventListener('click', handleCanvasClick);
        window.addEventListener('resize', resize);
        
        requestAnimationFrame(gameLoop);
    }

    init();
});
</script>
<script src = "../eventSender.js"></script>
</body>
</html>

