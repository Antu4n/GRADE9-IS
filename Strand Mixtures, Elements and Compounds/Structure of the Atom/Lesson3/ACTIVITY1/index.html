<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Shell Fill Game</title>
<style>
    /* Font Imports and Keyframes */
    @font-face {
        font-family: 'Fredoka';
        src: url('../assets/Fredoka-VariableFont_wdth\,wght.ttf') format('truetype');
    }
    @keyframes glow-pulse {
        0%, 100% { box-shadow: 0 0 10px rgba(251, 176, 59, 0.5), 0 0 20px rgba(251, 176, 59, 0.3); transform: scale(1); }
        50% { box-shadow: 0 0 20px rgba(251, 176, 59, 0.8), 0 0 30px rgba(251, 176, 59, 0.5); transform: scale(1.1); }
    }
    @keyframes glow-pulse-white {
        0%, 100% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.7), 0 0 20px rgba(255, 255, 255, 0.5); transform: scale(1); }
        50% { box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 30px rgba(255, 255, 255, 0.7); transform: scale(1.1); }
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideIn { from { transform: translateY(30px) scale(0.95); opacity: 0; } to { transform: translateY(0) scale(1); } }

    /* Root Variables */
    :root {
        --primary-color: #5D04B2;
        --secondary-color: #fbb03b;
        --correct-color: #4caf50;
        --incorrect-color: #e74c3c;
        --text-color-dark: #333;
        --text-color-light: #fff;
        --card-background-light: #ffffff;
        --shadow-dark: rgba(0, 0, 0, 0.3);
        --border-radius: 1rem;
        --header-font: 'Fredoka', sans-serif;
    }

    /* Global Reset & Base Styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100vh; overflow: hidden; }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #f0f4f8;
        font-family: var(--header-font), sans-serif;
        padding: 0.5rem;
    }

    #game-wrapper {
        width: 100%;
        max-width: 1200px;
        aspect-ratio: 16 / 9;
        box-shadow: 0 15px 40px var(--shadow-dark);
        overflow: hidden;
        position: relative;
        display: flex;
        flex-direction: column;
        background: var(--card-background-light);
    }

    #game-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .screen {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        display: flex;
        flex-direction: column;
        transition: opacity 0.5s ease-in-out;
        overflow: hidden;
    }
    .screen.hidden { opacity: 0; pointer-events: none; }
    
    #start-screen {
       background-image: url('images/gamebg.jpg');
       background-size: cover;
       background-position: center;
       justify-content: center;
       align-items: center;
       padding: 2rem;
       text-align: center;
    }
    #start-screen h1 {
       font-size: clamp(2.5rem, 5vw, 4.2rem);
       color: var(--text-color-light);
       margin-bottom: 1.2rem;
       text-shadow: 0 4px 8px rgba(0,0,0,0.3);
       font-weight: 500;
    }
    .start-button { 
        background: #FBB03B; color: #fff; font-weight: 900;
        font-size: 1.1rem; border: 3px solid #fff; border-radius: 3rem;
        padding: 0.75rem 2.25rem; margin-top: 1rem; cursor: pointer;
        text-shadow: 0 2px 0 #b88b2a; transition: all 0.2s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .start-button:hover { transform: scale(1.06); box-shadow: 0 6px 24px rgba(0,0,0,0.18); }

    #game-screen { background: #f8f9ff; }

    .game-top-section {
        width: 100%; flex-shrink: 0; display: flex; justify-content: space-between;
        align-items: center; background-color: var(--primary-color);
        color: var(--text-color-light); padding: clamp(0.5rem, 1.5vmin, 0.75rem) clamp(0.75rem, 2vmin, 1.25rem);
        box-shadow: 0 2px 10px rgba(0,0,0,0.2); gap: 1rem; flex-wrap: wrap;
    }
    
    #game-title {
        font-size: clamp(1.2rem, 4vmin, 1.8rem); font-weight: 600;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3); flex: 1 1 300px; min-width: 0;
    }

    .progress-area { display: flex; align-items: center; gap: clamp(0.5rem, 1.5vw, 1rem); flex-shrink: 0; }
    #progress-container {
        width: clamp(100px, 20vw, 200px); background-color: rgba(255,255,255,0.3);
        border-radius: 1rem; height: clamp(15px, 2.5vmin, 20px);
        border: 2px solid #fff; position: relative; overflow: hidden;
    }
    #progress-bar {
        height: 100%; width: 0%; background: #FFFF00;
        border-radius: 0.8rem; transition: width 0.5s ease;
    }
    #progress-text {
        color: var(--text-color-light); font-weight: 700;
        font-size: clamp(0.75rem, 2vmin, 1rem); text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
    }
    .instructions-icon {
        width: 40px; height: 40px; background: rgba(255, 255, 255, 0.2); border-radius: 50%;
        display: flex; align-items: center; justify-content: center; cursor: pointer;
        transition: all 0.3s ease; flex-shrink: 0; animation: glow-pulse-white 2s infinite;
    }
    .instructions-icon:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.1); }
    .instructions-icon svg { fill: white; width: 20px; height: 20px; }

    .game-content {
        flex: 1; display: flex; padding: clamp(0.5rem, 1vw, 1rem);
        overflow: hidden; position: relative;
    }

    #canvas-container {
        flex: 1; height: 100%; position: relative;
        min-width: 0; display: flex; align-items: center; justify-content: center;
    }

    canvas {
        display: block; background-color: #fff;
        border-radius: var(--border-radius);
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        cursor: grab; touch-action: none;
    }
    
    #controls {
        display: flex; justify-content: center; gap: 1rem;
        padding: 0.75rem; background-color: #e9ecef; border-top: 1px solid #dee2e6;
    }
    
    .ctrl-btn {
        font-family: var(--header-font); font-size: clamp(0.9rem, 2vw, 1.1rem); font-weight: bold;
        color: white; border: none; border-radius: 50px; padding: clamp(0.5rem, 2vh, 0.7rem) clamp(1rem, 4vw, 1.8rem);
        cursor: pointer; transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2), inset 0 -4px 0 rgba(0,0,0,0.2);
        text-shadow: 1px 1px 2px rgba(0,0,0,0.4); min-width: 140px;
    }
    .ctrl-btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0,0,0,0.3), inset 0 -2px 0 rgba(0,0,0,0.1); }
    .ctrl-btn:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 2px 8px rgba(0,0,0,0.2), inset 0 -1px 0 rgba(0,0,0,0.2); }
    .ctrl-btn:disabled { background: #bdc3c7; cursor: not-allowed; box-shadow: 0 2px 5px rgba(0,0,0,0.1), inset 0 -2px 0 rgba(0,0,0,0.1); }
    
    #resetBtn { background: linear-gradient(145deg, #e67e22, #d35400); }
    #checkBtn { background: linear-gradient(145deg, #27ae60, #229954); }

    /* Hint Icon */
    .hint-icon {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        width: 50px;
        height: 50px;
        background: var(--secondary-color);
        border-radius: 50%;
        border: 2px solid white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1001;
        box-shadow: 0 4px 15px rgba(251, 176, 59, 0.4);
        animation: glow-pulse 2s infinite;
    }
    .hint-icon:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 25px rgba(251, 176, 59, 0.8);
    }
    .hint-icon svg {
        fill: white;
        width: 24px;
        height: 24px;
    }

    /* Modal Styles */
    .modal-overlay, .overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.4); backdrop-filter: blur(5px);
        z-index: 3000; display: flex; justify-content: center; align-items: center;
        animation: fadeIn 0.3s ease;
    }
    .modal-overlay.hidden, .overlay.hidden { display: none; }
    .modal-content, .modal {
        background: var(--card-background-light); padding: 2.5rem;
        border-radius: var(--border-radius); text-align: center;
        width: 90%; max-width: 600px;
        animation: slideIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
    }
    .modal-content h2, .modal h2 {
      font-size: 2rem; font-weight: 600; margin-bottom: 1.5rem;
      color: var(--primary-color);
    }
    .modal-content p, .modal p { font-size: 1.5rem; line-height: 1.6; color: var(--text-color-dark); }
     .modal ul {
        list-style-type: none; text-align: left; margin-top: 1rem; padding: 0;
    }
    .modal li { margin-bottom: 0.8rem; padding-left: 1.5rem; position: relative; }
    .modal li::before {
        content: '‚û°Ô∏è'; position: absolute; left: 0;
    }

    .modal-btn {
        width: 100%; padding: 1rem; font-size: 1.2rem; font-weight: 700;
        border: none; border-radius: 0.75rem; cursor: pointer; color: #fff;
        background-color: var(--primary-color); transition: transform 0.2s, box-shadow 0.2s;
        margin-top: 1.5rem;
    }
    .modal-btn:hover { transform: scale(1.02); }

    #activity-intro-overlay .modal-content, #instructions-overlay .modal-content { border-top: 8px solid var(--primary-color); }
    #activity-intro-overlay .modal-content p {
        text-align: left; background: #f8f9fa; padding: 1.5rem;
        border-radius: 0.75rem; border-left: 4px solid var(--primary-color);
        line-height: 1.5; font-size: 1.5rem; color: var(--text-color-dark);
    }
    #instructions-overlay .modal-content ul, #hint-overlay .modal-content ul {
        text-align: left; padding: 0; font-size: 1.1rem; line-height: 1.5;
    }
    #instructions-overlay .modal-content li, #hint-overlay .modal-content li {
        margin-bottom: 0.8rem; font-size: 1.1em; line-height: 1.5;
    }
    #instructions-overlay .modal-content .hint-list { margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #eee; }
    #instructions-overlay .modal-content .hint-list li::before, #hint-overlay .modal-content .hint-list li::before { content: 'üí°'; }

    #hint-overlay .modal-content { border-top: 8px solid var(--secondary-color); }
    #hint-overlay h2 { color: var(--secondary-color); }
    #hint-overlay .modal-btn { background-color: var(--secondary-color); }

    #feedback-modal-overlay .modal-content { border-top: 8px solid; }

    /* Completion & Takeaways Overlay Styles */
    #completion-overlay { 
        background-image: url('images/gamebg.jpg'); background-size: cover; background-position: center;
        flex-direction: column; justify-content: center; align-items: center;
    }
    .completion-title-banner { 
        font-size: clamp(2rem, 7vmin, 4rem); text-shadow: 0 4px 8px rgba(0,0,0,0.3);
        text-align: center; color: #fff; font-family: var(--header-font);
        position: absolute; top: 5%; width: 100%;
        font-weight: 500;
    }
    #completion-overlay .modal {
        background: transparent; box-shadow: none; padding: 0; overflow: visible;
        width: auto; max-width: none;
    }
    #completion-image { 
        width: clamp(400px, 70%, 700px); max-width: 85%; height: auto;
        border: 3px solid var(--secondary-color); border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3); margin-top: 0.5rem;
    }
    .completion-buttons {
        position: absolute; bottom: 2rem; width: 100%; display: flex;
        justify-content: space-between; gap: 1.5rem; padding: 0 2rem;
    }
    .completion-btn {
       background: #FBB03B; color: #fff; font-weight: 700;
       font-size: 1.1rem; border: 0.1875rem solid #fff;
       border-radius: 3rem; padding: 0.75rem 2.25rem;
       margin-top: 1rem; cursor: pointer; letter-spacing: 0.02em;
       transition: all 0.2s; box-shadow: 0 0.25rem 0.5rem rgba(0,0,0,0.2);
    }
    .completion-btn:hover { transform: scale(1.05); }
    
    .visually-hidden {
        position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0;
        overflow: hidden; clip: rect(0, 0, 0, 0); border: 0;
    }
    
    @media (max-width: 991px) {
       #game-wrapper {
            width: 100vw !important; height: 100vh !important;
            min-width: 100vw !important; min-height: 100vh !important;
            border-radius: 0 !important; max-width: none !important;
            aspect-ratio: unset !important; box-shadow: none;
        }
        #completion-image { max-width: 60%; }
        .completion-buttons {align-items: center; bottom: 1rem; gap: 1rem; flex-wrap: wrap; }
        #activity-intro-overlay .modal-content, #instructions-overlay .modal-content, #hint-overlay .modal-content { height: 90vh; overflow-y: auto; }

    }
    
    @media (max-width: 768px) {
        body { padding: 0; }
    }
</style>
</head>
<body>
<div id="game-wrapper">
   <div id="game-container">
        <div id="start-screen" class="screen">
            <h1>Shell Fill Game</h1>
            <button class="start-button">Start Activity</button>
        </div>

        <div id="game-screen" class="screen hidden">
            <div class="game-top-section">
               <h1 id="game-title">Build the Atom</h1>
               <div class="progress-area">
                   <div id="progress-container"><div id="progress-bar"></div></div>
                   <div id="progress-text">0 / 9</div>
               </div>
               <div class="instructions-icon" id="instructions-icon">
                   <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
               </div>
            </div>
            <div class="game-content">
                <main id="canvas-container">
                    <canvas id="activityCanvas" role="img" aria-label="Interactive shell filling puzzle."></canvas>
                </main>
                 <div class="hint-icon" id="hint-icon">
                    <svg viewBox="0 0 24 24"><path d="M9 21c0 .5.4 1 1 1h4c.6 0 1-.5 1-1v-1H9v1zm3-19C8.1 2 5 5.1 5 9c0 2.4 1.2 4.5 3 5.7V17c0 .5.4 1 1 1h6c.6 0 1-.5 1-1v-2.3c1.8-1.3 3-3.4 3-5.7 0-3.9-3.1-7-7-7z"></path></svg>
                </div>
            </div>
            <div id="controls">
                <button id="resetBtn" class="ctrl-btn">Reset Electrons</button>
                <button id="checkBtn" class="ctrl-btn" disabled>Check Configuration</button>
            </div>
        </div>

        <div id="activity-intro-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <h2 style= 'color: var(--primary-color);'>Activity Introduction</h2>
                <p>Electrons do not just float around randomly‚Äîthey follow a special rule! Just like seats in a bus or riders in an elevator, electrons fill energy levels in order. In this game, drag electrons to the correct shell. Start from the first shell and move outward. Ready to fill the atom?</p>
                <button class="modal-btn" id="intro-continue-btn">Continue</button>
            </div>
        </div>

        <div id="instructions-overlay" class="modal-overlay hidden">
           <div class="modal-content">
               <h2 style = 'color: var(--primary-color);margin-bottom: 1.5rem; font-size: 2.2rem;'>Learner Instructions</h2>
               <ul>
                   <li>Drag each ‚ö™ electron to its correct shell.</li>
                   <li>The first shell holds a maximum of 2 electrons.</li>
                   <li>The second shell holds up to 8 electrons.</li>
                   <li>The third shell holds up to 8 electrons.</li>
                   <li>Drop electrons one at a time into each ring. Watch out for the limits!</li>
               </ul>
               <button class="modal-btn" id="close-instructions-btn">Got it!</button>
           </div>
        </div>

        <div id="hint-overlay" class="modal-overlay hidden">
           <div class="modal-content">
               <h2>Here's a Hint...</h2>
               <ul class="hint-list">
                   <li>You cannot skip a shell. Fill inner shells first.</li>
                   <li><b>1st shell</b> ‚Üí Max 2 electrons.</li>
                   <li><b>2nd shell</b> ‚Üí Max 8 electrons.</li>
                   <li><b>3rd shell</b> ‚Üí Max 8 electrons.</li>
                   <li>Example: Lithium (3 electrons) is 2 in the 1st shell, 1 in the 2nd.</li>
               </ul>
               <button class="modal-btn" id="close-hint-btn">Got it</button>
           </div>
        </div>
       
        <div id="feedback-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <h2 id="feedback-title"></h2><p id="feedback-text"></p>
                <button class="modal-btn" id="feedback-continue-btn">Continue</button>
            </div>
        </div>

        <div id="completion-overlay" class="overlay hidden">
            <div class="completion-title-banner">Activity Wrap Up!</div>
            <div class="modal">
                <img id="completion-image" src="images/complete.jpg" alt="Activity Complete" onerror="this.style.display='none'">
            </div>
            <div class="completion-buttons">
                <button class="completion-btn btn-restart">Restart Activity</button>
                <button class="completion-btn btn-next">Next Activity</button>
            </div>
        </div>
        
        <div id="aria-live-announcer" class="visually-hidden" aria-live="polite"></div>
        
    <audio id="ding-sound" src="audio/ding.mp3" preload="auto"></audio>
    <audio id="buzz-sound" src="audio/buzz.mp3" preload="auto"></audio>
    <audio id="intro-sound" src="audio/intro.mp3" preload="auto"></audio>
    <audio id="outro-sound" src="audio/outro.mp3" preload="auto"></audio>
   </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Event Handling ---
    const sendEvent = (eventName, eventData) => {
        if (window.parent) {
            const event = new CustomEvent('lessonEvent', { detail: { name: eventName, data: eventData } });
            window.parent.document.dispatchEvent(event);
        }
    };
    const ActivityEvent = { END_ACTIVITY: 'END_ACTIVITY' };

    // --- Game Data ---
    const ELEMENTS_DATA = [
        { name: 'Hydrogen', symbol: 'H', atomicNumber: 1, config: '1' },
        { name: 'Helium', symbol: 'He', atomicNumber: 2, config: '2' },
        { name: 'Lithium', symbol: 'Li', atomicNumber: 3, config: '2.1' },
        { name: 'Beryllium', symbol: 'Be', atomicNumber: 4, config: '2.2' },
        { name: 'Fluorine', symbol: 'F', atomicNumber: 9, config: '2.7' },
        { name: 'Neon', symbol: 'Ne', atomicNumber: 10, config: '2.8' },
        { name: 'Magnesium', symbol: 'Mg', atomicNumber: 12, config: '2.8.2' },
        { name: 'Sulfur', symbol: 'S', atomicNumber: 16, config: '2.8.6' },
        { name: 'Argon', symbol: 'Ar', atomicNumber: 18, config: '2.8.8' }
    ];

    // --- DOM Elements ---
    const startScreen = document.getElementById('start-screen'), gameScreen = document.getElementById('game-screen');
    const startBtn = document.querySelector('.start-button');
    const canvas = document.getElementById('activityCanvas'), ctx = canvas.getContext('2d');
    const canvasContainer = document.getElementById('canvas-container');
    const gameTitle = document.getElementById('game-title');
    const resetBtn = document.getElementById('resetBtn'), checkBtn = document.getElementById('checkBtn');
    const announcer = document.getElementById('aria-live-announcer');
    const progressBar = document.getElementById('progress-bar'), progressText = document.getElementById('progress-text');
    const activityIntroOverlay = document.getElementById('activity-intro-overlay'), introContinueBtn = document.getElementById('intro-continue-btn');
    const instructionsIcon = document.getElementById('instructions-icon'), instructionsOverlay = document.getElementById('instructions-overlay'), closeInstructionsBtn = document.getElementById('close-instructions-btn');
    const hintIcon = document.getElementById('hint-icon'), hintOverlay = document.getElementById('hint-overlay'), closeHintBtn = document.getElementById('close-hint-btn');
    const feedbackModalOverlay = document.getElementById('feedback-modal-overlay'), feedbackTitle = document.getElementById('feedback-title'), feedbackText = document.getElementById('feedback-text'), feedbackContinueBtn = document.getElementById('feedback-continue-btn');
    const completionOverlay = document.getElementById('completion-overlay');
    const dingSound = document.getElementById('ding-sound'), buzzSound = document.getElementById('buzz-sound'), introSound = document.getElementById('intro-sound'), outroSound = document.getElementById('outro-sound');

    // Canvas & Sizing
    let W = 960, H = 540; const dpr = window.devicePixelRatio || 1;

    // Game State
    let state = { items: [], zones: [] };
    let images = {}, isPaused = true, currentElementIndex = 0;
    const imageSources = { electron: 'images/electron.png' };
    let draggedItem = null, pointerOffset = { x: 0, y: 0 };
    
    // Asset Loading & Sound
    function loadImages(callback) {
        images.electron = new Image();
        images.electron.src = imageSources.electron;
        images.electron.onload = callback;
        images.electron.onerror = () => { console.error(`Failed to load image: ${imageSources.electron}`); callback(); };
    }
    function playSound(sound) { if(sound) { sound.currentTime = 0; sound.play().catch(e => {}); } }
    function stopSound(sound) { if(sound) { sound.pause(); } }

    // Activity Setup
    function loadElement(index) {
        if (index >= ELEMENTS_DATA.length) {
            showCompletionScreen();
            return;
        }
        isPaused = false;
        const element = ELEMENTS_DATA[index];
        gameTitle.textContent = `Build a ${element.name} Atom`;
        
        state = { items: [], zones: [] };
        const electronR = H * 0.07; 
        const electronBayY = H * 0.92;

        for (let i = 0; i < element.atomicNumber; i++) {
            // ROBUST ELECTRON POSITIONING LOGIC
            let spacing = electronR * 2.4; // Diameter + small gap
            let totalRequiredWidth = element.atomicNumber * spacing;
            
            // If the total width exceeds 95% of canvas width, shrink the spacing to fit
            if (totalRequiredWidth > W * 0.95) {
                spacing = (W * 0.95) / element.atomicNumber;
            }

            const firstElectronX = (W / 2) - ((element.atomicNumber - 1) * spacing / 2);
            const homeX = firstElectronX + i * spacing;
            
            state.items.push({ 
                id: `e${i}`, 
                kind: 'electron', 
                img: images.electron, 
                r: electronR, 
                homeX: homeX, homeY: electronBayY, 
                placedIn: null, 
                shake: 0, 
                x: homeX, y: electronBayY 
            });
        }
        
        state.zones = [
            { id: 'orbit1', kind: 'orbit', x: W / 2, y: H * 0.45, r: H * 0.20, accepts: ['electron'], items: [], capacity: 2 },
            { id: 'orbit2', kind: 'orbit', x: W / 2, y: H * 0.45, r: H * 0.32, accepts: ['electron'], items: [], capacity: 8 },
            { id: 'orbit3', kind: 'orbit', x: W / 2, y: H * 0.45, r: H * 0.44, accepts: ['electron'], items: [], capacity: 8 }
        ];

        checkBtn.disabled = true;
        updateProgress();
    }
    
    // UI, Feedback & State Checks
    function updateProgress() {
        const totalElements = ELEMENTS_DATA.length;
        progressBar.style.width = `${(currentElementIndex / totalElements) * 100}%`;
        progressText.textContent = `${currentElementIndex} / ${totalElements}`;
    }

    function showFeedbackModal(type, title, message) {
        isPaused = true;
        const modalContent = feedbackModalOverlay.querySelector('.modal-content');
        const modalBtn = feedbackModalOverlay.querySelector('.modal-btn');
        feedbackTitle.textContent = title;
        feedbackText.textContent = message;

        const color = type === 'correct' ? 'var(--correct-color)' : 'var(--incorrect-color)';
        modalContent.style.borderColor = color;
        feedbackTitle.style.color = color;
        modalBtn.style.backgroundColor = color;
        
        feedbackModalOverlay.classList.remove('hidden');
        if (type === 'correct') { playSound(dingSound); } else { playSound(buzzSound); }
    }

    function getIncorrectFeedback(userConfigArr) {
        if (userConfigArr[0] > 2) return "The first shell is overfilled. It can only hold a maximum of 2 electrons.";
        if (userConfigArr[1] > 8) return "The second shell is overfilled. It can only hold a maximum of 8 electrons.";
        if (userConfigArr[2] > 8) return "The third shell is overfilled. It can only hold a maximum of 8 electrons.";
        if (userConfigArr.length > 1 && userConfigArr[0] < 2) return "You cannot skip a shell. The first shell must be filled with 2 electrons before adding to the second shell.";
        if (userConfigArr.length > 2 && userConfigArr[1] < 8) return "You cannot skip a shell. The second shell must be filled with 8 electrons before adding to the third shell.";
        return "That's not the correct configuration. Remember to fill the shells in order from the inside out.";
    }
    
   function checkConfiguration() {
        let userConfigArr = state.zones.map(z => z.items.length);
        while(userConfigArr.length > 0 && userConfigArr[userConfigArr.length-1] === 0) {
            userConfigArr.pop();
        }
        let userConfigStr = userConfigArr.join('.');

        const correctConfig = ELEMENTS_DATA[currentElementIndex].config;

        if(userConfigStr === correctConfig) {
            showFeedbackModal('correct', 'Configuration Correct!', `Excellent! The configuration for ${ELEMENTS_DATA[currentElementIndex].name} is indeed ${correctConfig}.`);
            
            const isLastElement = currentElementIndex === ELEMENTS_DATA.length - 1;

            if (isLastElement) {
                feedbackContinueBtn.textContent = "Finish Activity";
                feedbackContinueBtn.onclick = () => {
                    feedbackModalOverlay.classList.add('hidden');
                    isPaused = true; // Pause interaction during the delay
               
                        showCompletionScreen();
                };
            } else {
                feedbackContinueBtn.textContent = "Next Element";
                feedbackContinueBtn.onclick = () => {
                    feedbackModalOverlay.classList.add('hidden');
                    isPaused = true; // Pause interaction during the delay
                        currentElementIndex++;
                        loadElement(currentElementIndex);
                };
            }
        } else {
            const feedbackMessage = getIncorrectFeedback(userConfigArr);
            showFeedbackModal('incorrect', 'Not Quite Right', feedbackMessage);
            feedbackContinueBtn.textContent = "Try Again";
            feedbackContinueBtn.onclick = () => {
                feedbackModalOverlay.classList.add('hidden');
                loadElement(currentElementIndex);
            };
        }
    }
    function showCompletionScreen(){
        isPaused = true;
        sendEvent(ActivityEvent.END_ACTIVITY, { activityName: 'Shell Fill Game' });
        completionOverlay.classList.remove('hidden');
        playSound(outroSound);
        const conclusionTitle = completionOverlay.querySelector('.completion-title-banner');
        conclusionTitle.textContent = "Activity Wrap Up!";
    }

    // Interaction & Animations
    function shakeAndReturn(item) {
        item.shake = 0.5;
    }
    function updateAnimations(dt) {
        state.items.forEach(item => {
            if (item.shake > 0) {
                item.shake -= dt;
                if (item.shake <= 0) {
                    item.shake = 0;
                    item.x = item.homeX;
                    item.y = item.homeY;
                }
            }
        });
    }

    // Drawing
    function draw() {
        ctx.clearRect(0, 0, W, H);
        if (!state.items) return;
        drawStaticElements();
        const itemsToDraw = [...state.items.filter(i => i !== draggedItem), draggedItem].filter(Boolean);
        
        itemsToDraw.forEach(item => {
            const shakeX = item.shake > 0 ? Math.sin(item.shake * Math.PI * 16) * (W * 0.01) : 0;
            const radius = (item === draggedItem) ? item.r * 1.2 : item.r;
            if (item.img && item.img.complete && item.img.naturalHeight !== 0) {
                ctx.drawImage(item.img, item.x - radius + shakeX, item.y - radius, radius * 2, radius * 2);
            }
        });
    }

    function drawStaticElements() {
        if (!state || !state.zones) return;
        ctx.save();
        ctx.lineWidth = W * 0.003;
        ctx.strokeStyle = '#d0d0d0';
        ctx.setLineDash([W*0.01, W*0.01]);
        state.zones.forEach(z => {
             ctx.beginPath();
             ctx.arc(z.x, z.y, z.r, 0, 2 * Math.PI);
             ctx.stroke();
        });

        const nucleusRadius = H * 0.12;
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(142, 68, 173, 0.8)';
        ctx.strokeStyle = '#5D04B2';
        ctx.lineWidth = W * 0.005;
        ctx.beginPath();
        ctx.arc(W / 2, H * 0.45, nucleusRadius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();

        const element = ELEMENTS_DATA[currentElementIndex];
        if(element){
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const fontSize = element.symbol.length > 1 ? nucleusRadius * 0.7 : nucleusRadius * 0.9;
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.body).fontFamily}`;
            ctx.fillText(element.symbol, W / 2, H * 0.45);
        }

        ctx.restore();
    }
    
    // Event Handlers
    function getLocalPoint(e) {
        const r = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: (clientX - r.left) * (W / r.width), y: (clientY - r.top) * (H / r.height) };
    }

    function onPointerDown(e) {
        if (isPaused) return;
        e.preventDefault();
        const p = getLocalPoint(e);
        for (let i = state.items.length - 1; i >= 0; i--) {
            const item = state.items[i];
            if (Math.hypot(p.x - item.x, p.y - item.y) < item.r) {
                if (item.placedIn) {
                    const zone = item.placedIn;
                    zone.items = zone.items.filter(i => i.id !== item.id);
                    item.placedIn = null;
                }
                draggedItem = item;
                pointerOffset = { x: p.x - item.x, y: p.y - item.y };
                canvas.style.cursor = 'grabbing';
                break;
            }
        }
    }

    function onPointerMove(e) {
        if (!draggedItem) return;
        e.preventDefault();
        const p = getLocalPoint(e);
        draggedItem.x = p.x - pointerOffset.x;
        draggedItem.y = p.y - pointerOffset.y;
    }

    function onPointerUp() {
        if (!draggedItem) return;
        canvas.style.cursor = 'grab';
        let snapped = false;

        for (const zone of state.zones) {
            const dist = Math.abs(Math.hypot(draggedItem.x - zone.x, draggedItem.y - zone.y) - zone.r);
            if (dist < W * 0.03) {
                 draggedItem.placedIn = zone; 
                 zone.items.push(draggedItem);
                 const angle = Math.atan2(draggedItem.y-zone.y, draggedItem.x-zone.x);
                 draggedItem.x = zone.x + zone.r * Math.cos(angle); draggedItem.y = zone.y + zone.r * Math.sin(angle);
                 snapped = true;
                 break;
            }
        }
        
        if (!snapped) { shakeAndReturn(draggedItem); }
        draggedItem = null;

        const totalPlaced = state.items.filter(item => item.placedIn !== null).length;
        const currentElement = ELEMENTS_DATA[currentElementIndex];
        if (currentElement) {
             checkBtn.disabled = totalPlaced !== currentElement.atomicNumber;
        }
    }
    
    let lastTime = 0;
    function loop(t) {
        if(!lastTime) lastTime=t; const dt=(t-lastTime)/1000; lastTime=t;
        if(!isPaused) updateAnimations(dt);
        draw(); requestAnimationFrame(loop);
    }
    
    function resize() {
        const r = canvasContainer.getBoundingClientRect(); if (r.width === 0 || r.height === 0) return;
        const aspect = 16 / 9; let w = r.width, h = r.width / aspect;
        if (h > r.height) { h = r.height; w = r.height * aspect; }
        canvas.style.width = `${w}px`; canvas.style.height = `${h}px`;
        canvas.width = Math.floor(w*dpr); canvas.height = Math.floor(h*dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); W = w; H = h;
        if (!isPaused) loadElement(currentElementIndex);
    }

    function announce(text) { announcer.textContent = text; }
    
    function init() {
        startBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden'); gameScreen.classList.remove('hidden');
            activityIntroOverlay.classList.remove('hidden'); isPaused = true;
            resize(); 
            playSound(introSound);
            sendEvent(ActivityEvent.START_ACTIVITY, { activityName: 'Shell Fill Game' });
        });
        introContinueBtn.addEventListener('click', () => {
            activityIntroOverlay.classList.add('hidden');
            isPaused = false;
            stopSound(introSound);
            loadElement(currentElementIndex);
        });
        instructionsIcon.addEventListener('click', () => { instructionsOverlay.classList.remove('hidden'); isPaused = true; });
        closeInstructionsBtn.addEventListener('click', () => { instructionsOverlay.classList.add('hidden'); if(currentElementIndex < ELEMENTS_DATA.length) isPaused = false; });
        
        hintIcon.addEventListener('click', () => { hintOverlay.classList.remove('hidden'); isPaused = true; });
        closeHintBtn.addEventListener('click', () => { hintOverlay.classList.add('hidden'); if(currentElementIndex < ELEMENTS_DATA.length) isPaused = false; });

        resetBtn.addEventListener('click', () => loadElement(currentElementIndex));
        checkBtn.addEventListener('click', checkConfiguration);

        completionOverlay.querySelector('.btn-restart').addEventListener('click', () => {
            stopSound(outroSound); completionOverlay.classList.add('hidden'); 
            currentElementIndex = 0;
            initializeGame();
        });
      
        completionOverlay.querySelector('.btn-next').addEventListener('click', () => {
            window.location.href = "ACTIVITY2/index.html";
            sendEvent(ActivityEvent.END_ACTIVITY, { activityName: 'Shell Fill Game' });
        });
        
        canvas.addEventListener('mousedown', onPointerDown); window.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('touchstart', onPointerDown, { passive: false }); window.addEventListener('touchend', onPointerUp);
        canvas.addEventListener('touchmove', onPointerMove, { passive: false });
        window.addEventListener('resize', resize);
        loadImages(() => { requestAnimationFrame(loop); });
    }
    
    function initializeGame() {
        startScreen.classList.remove('hidden');
        gameScreen.classList.add('hidden');
        completionOverlay.classList.add('hidden');
        isPaused = true;
        currentElementIndex = 0;
        updateProgress();
    }

    init();
});
</script>
<script src ="../eventSender.js"></script>
</body>
</html>